MSB7102:Bio-Conductor and R (4 CU). Figure1.1.2.bioconductor_and_r_image_001.jpg. Course Description: The increasing volume and complexity of data is a major ‘problem’ in data management, analysis and visualization especially in bioscience research. The R programming language is open source and provides a general and flexible computing environment and the Bioconductor project which is built on top of R also provides powerful and flexible tools specifically designed to analyse biological data. R is particularly powerful for statistical and quantitative analysis, but in recent years its open-source nature has allowed it to grow in other dimensions like text processing and pattern finding that are crucial in the processing of biological data. This course will teach students how to use both R and Bioconductor to analyse, summarise and visualize quantitative data. Course Objectives and Learning Outcomes: At the end of this course, the student should be able to: 1. Download and install R, RStudio Integrated Development Environment (IDE), Bioconductor and other R add-in packages. 2. Navigate and optimise RStudio. 3. Learn the main R data structures e.g., vectors, data frames, lists, arrays. 4. Write and interpret R syntax including control structures, functions, loops and.  regular expressions. 5. Import and export data in R. 6. Data processing and manipulation techniques: The Tidyverse suit of R packages. 7. Produce data visualisations in base R and with the ggplot package and other sister packages. 8. Statistical data analysis in R. 9. Debug ie., Solve fundamental error problems (Find and correct errors). 10. Generate Reports using R Markdown. 11. Understand the R Bioconductor project and explore some of the Bioconductor packages. Mode of Delivery: This course will encourage participatory and active learning. Learning will be facilitated through lectures, practical assignments given in form of Individual and group work. Weekly lectures or tutorial followed by computer practical. Reading List/References: 1. The R Project for Statistical Computing (http://www.r-project.org). 2. R for Data Science (https://r4ds.had.co.nz/). 3. R programming for data science (https://bookdown.org/rdpeng/rprogdatascience/). 4. The Little Books of R (https://little-books-of-r.readthedocs.io/en/latest/). 5.  simpleR - Using R for Introductory Statistics (John Verzani, 2004). 6. Bioinformatics and Computational Biology Solutions Using R and Bioconductor. (Gentleman et al., 2005). 7. Gentleman, R. (2008). R programming for bioinformatics.CRC Press. 8. Introduction to statistical data analysis with R, (Matthias Kohl, 2015). 9. Data Visualisation with R, (Thomas Rahlf, 2017). What is R? ● R is a programming language for statistical computing and graphics. ● It is a dialect of the S language which was initiated in 1976 by the Bell Labs. ● First version of R (R v1. 0. 0) was released in 2000. ● Current version at 4. 3. 1 (Beagle Scouts) released on 2023-June-16. ● Runs on almost any standard computing platform/OS - Windows, Linux, Mac, (even on the PlayStation). Features of R. ● R is an open source (free) software, this implies; ○ Freedom to run the program, for any purpose. ○ Freedom to study how the program works, and adapt it to your needs. ○ Freedom to redistribute copies so you can help your neighbour. ○ Freedom to improve the program, and release your improvements to the public, so that the whole community benefits. ● Graphics capabilities very sophisticated and better than most statistical packages. ● It has frequent version releases, that is, an active development. ● Its functionality is divided into modular packages. ● Useful for interactive work, but also has a powerful programming language for developing new tools. ● Very active and vibrant user community; R-help and R-devel mailing lists and Stack Overflow. ● Data variety - can support both structured and unstructured data types. ● Ability to run program codes without need for a compiler. ● Compatible with other programming languages such as C++, C or FORTRAN. ● Interacting with databases - Has a number of packages that help it interface with databases such as Roracle, RmySQL. Drawbacks of R. ● Functionality is based on consumer demand and user contributions. If no one feels like implementing your favourite method, then it’s your job! (Or you need to pay someone to do it). ● Objects must generally be stored in physical memory; but there have been advancements to deal with this. ● Not ideal for all possible situations (but this is a drawback of all software packages). ● Poor security, hence not very recommended for web applications. ● No dedicated support team - there is an active community. ● Steep learning curve due its different syntax compared to other languages, as well as its data types. Design of R System. ● The R system is divided into 2 conceptual parts: ○ The “base” R system that you download from CRAN installed with R. ○ Everything else e.g., Bioconductor. ● R functionality is divided into a number of packages. ○ The “base” R system contains, among other things, the base package which is required to run R, and contains the most fundamental functions. ● Among other packages contained in the “base” system include utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk, stats4. ● There are many other packages available;. ○ About 18910 packages on CRAN. ○ Many packages associated with the Bioconductor project (http://bioconductor.org). ○ Some packages stored on personal websites or github. Installing R & R Studio. Figure2.1.2.bioconductor_and_r_image_002.jpg. ● https://cran.r-project.org/ - R. ● https://posit.co/download/rstudio-desktop/ - R studio. ● R - The actual programming langauge. ● Rstudio - Integrates with R as an IDE (Integrated Development Environment) to provide further functionality. Arithmetic Operations & Data Types in R. Figure3.1.2.bioconductor_and_r_image_003.jpg. Entering Input. ● 2 ways of getting input into R; prompt (interactive) and script. ● At the R prompt we type expressions. The <- symbol is the assignment operator. Figure4.1.2.bioconductor_and_r_image_004.jpg. ● The grammar of the language determines whether an expression is complete or not. Figure5.1.2.bioconductor_and_r_image_005.jpg. ● The # character indicates a comment. Anything to the right of the # (including the # itself) is ignored. This is the only comment character in R. Unlike some other languages, R does not support multi-line comments or comment blocks. Evaluation Or Getting Output. ● When a complete expression is entered at the prompt, it is evaluated and the result of the evaluated expression is returned. The result may be auto-printed. Figure6.1.2.bioconductor_and_r_image_006.jpg. ● NB: With interactive work, we do not explicitly print objects with the print function; it is much easier to just auto-print them by typing the name of the object and hitting return/enter. However, when writing scripts, functions, or longer programs, there is sometimes a need to explicitly print objects because auto printing does not work in those settings. ● The [1] indicates that x is a vector and 1 is the first element. The square brackets [ ] indicate the index of the element in a vector, e.g.,. Figure7.1.2.bioconductor_and_r_image_007.jpg. Atomic Classes of Objects in R. R has five basic or “atomic” classes of objects: 1. Character. Enclosed in quotes (“”). Also called strings in some languages. 2. Numeric (real numbers). Allow for decimal numbers (floats in some languages). 3. Integer. Only whole numbers. 4. Complex. 5. Logical (True/False). Numbers vs Integers. ● Numbers in R a generally treated as numeric objects (i.e., double precision real numbers). ● If you explicitly want an integer, you need to specify the L suffix. ● Ex: Entering 1 gives you a numeric object; entering 1L explicitly gives you an integer. ● There is also a special number Inf which represents infinity; e.g., 1 / 0; Inf can be used in ordinary calculations; e.g., 1 / Inf is 0. ● The value NaN represents an undefined value (“not a number”); e.g., 0 / 0; NaN can also be thought of as a missing value. Data Structures (Types) in R. Data structures are how R represents the atomic classes. There are 5 Data types in R. 1. Vectors. 2. Matrices. 3. Lists. 4. Factors. 5. Data Frames. 1. Vectors. ● The most basic object is a vector. ● A vector can only contain objects of the same class. ● BUT: The one exception is a list, which is represented as a vector but can contain objects of different classes (indeed, that’s usually why we use them). ● The c() function can be used to create vectors of objects. ● Empty vectors can be created with the vector() function. Creating Vectors. Creating a vector using the c() function. Figure8.1.2.bioconductor_and_r_image_008.jpg. Using the vector() function. Figure9.1.2.bioconductor_and_r_image_009.jpg. Mixing Objects - Coercion. ● What about the following?. Figure10.1.2.bioconductor_and_r_image_010.jpg. ● When different objects are mixed in a vector, coercion occurs so that every element in the vector is of the same class. ● If this coercion is done automatically by the program, it is referred to as implicit coercion. ● A user can also decide to coerce one class object to another, i.e., explicit coercion. Explicit Coercion. ● Objects can be explicitly coerced from one class to another using the as. * functions, if available. Figure11.1.2.bioconductor_and_r_image_011.jpg. ● Nonsensical coercion results in NAs. Figure12.1.2.bioconductor_and_r_image_012.jpg. 2. Matrices. ● Matrices are vectors with a dimension attribute. The dimension attribute is itself an integer vector of length 2 (nrow, ncol). ● They also contain elements of the same class. Figure13.1.2.bioconductor_and_r_image_013.jpg. Matrices are constructed column-wise, so entries can be thought of starting in the “upper left” corner and running down the columns. Figure14.1.2.bioconductor_and_r_image_014.jpg. Matrices can also be created directly from vectors by adding a dimension attribute. Figure15.1.2.bioconductor_and_r_image_015.jpg. cbind-ing and rbind-ing. ● Matrices can be created directly from vectors by column-binding or row-binding them using cbind() and rbind() function. Figure16.1.2.bioconductor_and_r_image_016.jpg. 3. Lists. ● Lists are a special type of vector that can contain elements of different classes. ● Lists are a very important data type in R and you should get to know them well. ● Lists can be explicitly created using the list() function. Figure17.1.2.bioconductor_and_r_image_017.jpg. 4. Factors. ● Factors are used to represent categorical data. ● Factors can be unordered or ordered. One can think of a factor as an integer vector where each integer has a label. ● Factors are treated specially by modelling functions like lm() and glm(). ● Using factors with labels is better than using integers because factors are self-describing; Having a variable that has values “Male” and “Female” is better than a variable that has values 1 and 2. ● Factor objects can be created with the factor() function or can be coerced using as.factor() function. ● Often factors will be automatically created for you when you read a dataset in using a function like read.table(). Figure18.1.2.bioconductor_and_r_image_018.jpg. ● The order of the levels can be set using the levels argument to factor(). This can be important in scenarios like linear modelling because the first level is used as the baseline level. Figure19.1.2.bioconductor_and_r_image_019.jpg. 5. Data Frames. ● Data frames are used to store tabular data. ● They are represented as a special type of list where every element of the list has to have the same length. ● Each element of the list can be thought of as a column and the length of each element of the list is the number of rows. ● Unlike matrices, data frames can store different classes of objects in each column. (just like lists); matrices must have every element be the same class. ● Data frames also have a special attribute called row.names. ● Data frames are usually created by calling read.table() or read.csv(). ● Can be converted to a matrix by calling data.matrix(). Figure20.1.2.bioconductor_and_r_image_020.jpg. Figure21.1.2.bioconductor_and_r_image_021.jpg. Missing Values. ● Missing values are denoted by NA or NaN for undefined mathematical operations. ● is.na() is used to test objects if they are NA. ● is.nan() is used to test for NaN. ● NA values have a class also, so there are integer NA, character NA, etc. ● A NaN value is also NA but the converse is not true. Figure22.1.2.bioconductor_and_r_image_022.jpg. Attributes. ● R objects can have attributes i.e. , predefined functions you can call on an object to.  know more about it. ○ names, dimnames. ○ dimensions (e.g. , matrices, arrays). ○ class. ○ length. ● Attributes of an object can be accessed using the attributes() function. Names. ● R objects can also have names, which is very useful for writing readable code and self-describing objects. Figure23.1.2.bioconductor_and_r_image_023.jpg. Figure24.1.2.bioconductor_and_r_image_024.jpg. Figure25.1.2.bioconductor_and_r_image_025.jpg. Subsetting in R. “Extracting a portion, a larger R object”. There are a number of operators that can be used to extract subsets of R objects. ● [. ] - (single square bracket) always returns an object of the same class as.  the original; can be used to select more than one element. ● [[. ]] - (double square brackets) is used to extract elements of a list or a data.  frame; it can only be used to extract a single element and the class of the.  returned object will not necessarily be a list or data frame (usually vector). ● $ - (dollar sign) is used to extract elements of a list or data frame by name;.  semantics are similar to that of [[. Subsetting a Vector. Figure26.1.2.bioconductor_and_r_image_026.jpg. Subsetting a matrix. Matrices can be subsetted in the usual way with (i,j) type indices. Figure27.1.2.bioconductor_and_r_image_027.jpg. Indices can also be missing. Figure28.1.2.bioconductor_and_r_image_028.jpg. Dropping matrix dimensions. By default, when a single element of a matrix is retrieved, it is returned as a vector of length 1 rather than a 1 × 1 matrix. This behaviour can be turned off by setting drop = FALSE. Figure29.1.2.bioconductor_and_r_image_029.jpg. Similarly, subsetting a single column or a single row will give you a vector, not a matrix (by.  default). Figure30.1.2.bioconductor_and_r_image_030.jpg. Subsetting Lists and dataframes. Lists and data frames can be subsetted using all three of the operators mentioned above, and all three are used for different purposes. ● A difference between [ and [[ is in the class of the object returned. ● [[ and $ will return the same class – a vector usually. ● One thing that differentiates the [[ operator from the $ is that the [[ operator can be used with computed indices. The $ operator can only be used with literal names. ● $ can only use a named element and not an index position. Subsetting Lists. Figure31.1.2.bioconductor_and_r_image_031.jpg. Figure32.1.2.bioconductor_and_r_image_032.jpg. Figure33.1.2.bioconductor_and_r_image_033.jpg. Partial Matching. ● Partial matching of names is allowed with [[ and $. ● Very useful during interactive work if the object you’re working with has very long.  element names. ● Just abbreviate those names and R will figure out what element you’re referring to. ● However, be careful no names have the same used abbreviation. ● Generally, not recommended for long scripts. Figure34.1.2.bioconductor_and_r_image_034.jpg. Removing NA values. ● Its a common task in data analysis is removing missing values (NAs). Figure35.1.2.bioconductor_and_r_image_035.jpg. ● Taking a subset of multiple objects with no missing values. Figure36.1.2.bioconductor_and_r_image_036.jpg. Reading Data into R. There are a few principal functions reading data into R. ● read.table, read.csv, for reading tabular data. ● readLines, for reading lines of a text file. ● source, for reading in R code files. ● load, for reading in saved workspaces. Reading Data with read.table(). The read.table function is one of the most commonly used functions for reading data. It has a few important arguments: ● file, the name of a file, or a connection. ● header, logical indicating if the file has a header line. ● sep, a string indicating how the columns are separated. ● colClasses, a character vector indicating the class of each column in the dataset. ● nrows, the number of rows in the dataset. ● comment.char, a character string indicating the comment character. ● skip, the number of lines to skip from the beginning. ● stringsAsFactors, should character variables be coded as factors?. For small to moderately sized datasets, you can usually call read.table without specifying any other arguments. Figure37.1.2.bioconductor_and_r_image_037.jpg. R will automatically;. ● skip lines that begin with a #. ● figure out how many rows there are (and how much memory needs to be allocated). ● figure what type of variable is in each column of the table. Telling R all these things directly, makes R run faster and more efficiently. ● read.csv is identical to read.table except that the default separator is a comma. To save data from R, Use: write.table, write.csv, writeLines, …. Control Structures in R. Control structures allow you control the flow of execution of an R program by incorporating logic into your code. This maybe in terms of how many times a code will run, or which code should run based on a given condition. Commonly used control structures are. ● if and else: testing a condition and acting on it. ● for: execute a loop a fixed number of times. ● while: execute a loop while a condition is true. ● repeat: execute an infinite loop (must break out of it to stop). ● break: break the execution of a loop. ● next: skip an iteration of a loop. Most control structures are not used in interactive sessions, but rather when writing functions or longer expressions.  if - else. ● One of the most used control structures in R and many other languages. ● It allows you check a given condition if it’s true and run some code, or run a different code.  block if its false. ● You can run the if statement alone (if you have only condition of interest) or use an if - else. (For 2 conditions, or use and if - else if - else (for multiple conditions). ● The else if block can be used a number of times in a block. Figure38.1.2.bioconductor_and_r_image_038.jpg. Figure39.1.2.bioconductor_and_r_image_039.jpg. Figure40.1.2.bioconductor_and_r_image_040.jpg.  if - else → Operators. Figure41.1.2.bioconductor_and_r_image_041.jpg. For loop. ● For loop iterates over a sequence of objects (vector, list, etc) and for every successive.  iteration, the value of the iterator variable changes. ● It runs for a finite number of times corresponding to the number of objects being.  iterated over. Figure42.1.2.bioconductor_and_r_image_042.jpg. Figure43.1.2.bioconductor_and_r_image_043.jpg. Nested for loops. ● It is possible having a for loop inside another for loop (nested for loop). ● Nested loops are commonly used with multidimensional data structures such as matrices, data frames or lists. ● Be careful with nesting though, Nesting beyond 2 to 3 levels often makes it difficult to read/understand the code. Figure44.1.2.bioconductor_and_r_image_044.jpg.  break, next. ● next is used skip an iteration of a loop. ● The break statement is used exit out of a loop. Break Statement. Figure45.1.2.bioconductor_and_r_image_045.jpg. Figure46.1.2.bioconductor_and_r_image_046.jpg. Next Statement. Figure47.1.2.bioconductor_and_r_image_047.jpg. Figure48.1.2.bioconductor_and_r_image_048.jpg. While loop. ● While loops begin by testing a condition. If it is true, then they execute the loop body. Once the loop body is executed, the condition is tested again, and so forth. ● While loops can potentially result in infinite loops if not written properly. Use with care! - Always have a code modifying the values of the condition. ● There can be more than one condition in a test. ● Conditions are always tested from left to right. ● Best suited when you don’t know the exact number of times the loop++ will run compared to for loops that run a defined number of times. Figure49.1.2.bioconductor_and_r_image_049.jpg. While loop →Example. Figure50.1.2.bioconductor_and_r_image_050.jpg. Figure51.1.2.bioconductor_and_r_image_051.jpg. Repeat loop. ● Repeat initiates an infinite loop from the start. ● Only way to exit out of a repeat loop is by calling the break statement. ● Its not commonly used, but has its own unique usages. ○ E.g. , Compute for a solution in a loop and only exit when you have the exact answer or close enough to exact answer. Figure52.1.2.bioconductor_and_r_image_052.jpg. Figure53.1.2.bioconductor_and_r_image_053.jpg. Functions in R. ● Functions are a block of statements that can be used repeatedly in a program. ● One or multiple statements of code are bundled in a single function name, which is called when needed. Once function name is called, it executes all the code bundled inside it. ● There are 2 types of functions: built-in or user-deﬁned. ● Functions can take on arguments when being called, or have default arguments or no arguments at all. Structure of functions. Figure54.1.2.bioconductor_and_r_image_054.jpg. Example function. Problem: Create a function that calculates the factorial of a non-negative integer. Figure55.1.2.bioconductor_and_r_image_055.jpg. Loop Functions in R. Why Loop Functions?. ● We have seen how to write our custom loops (such as for and while) to iterate over elements of a vector, list, data frame to apply a given function;. ● These are very important in programming, but not very easy when working interactively on console or command line. ● R has some inbuilt loop functions to implement looping in a compact form to make your R programming life easier. Loop functions - Apply family. 1.  lapply(): Loop over a list and evaluate a function on each element. 2.  sapply(): Same as lapply but try to simplify the result. 3.  apply(): Apply a function over the margins of an array. 4.  tapply(): Apply a function over subsets of a vector. 5.  mapply(): Multivariate version of lapply. 6.  rapply(): 1.  lapply() - loop over a list. What lapply() does;. 1. It loops over a list, iterating over each element in that list. 2. It applies a function to each element of the list (a function that you specify) and returns a list (the l is for “list”). 3. It takes in 3 arguments; a list, X; a function, FUN, to be applied; and any other arguments. ● If X is not a list, it will be coerced into a list using as.list() function. ● Will always return a list regardless of the class of input.  lapply() – Example. Figure56.1.2.bioconductor_and_r_image_056.jpg. Here the mean function is passed as an argument to the lapply() function. Figure57.1.2.bioconductor_and_r_image_057.jpg. We can also pass arguments to a function, for example the min and max arguments in the example above passed to the runif function instead of 0 and 1 default.  lapply() - using custom and anonymous functions. Instead of standard functions, we can also use custom-deﬁned functions or anonymous functions. Anonymous functions are “generated on the go” and deﬁned within the lappy, not saved in your workspace. Figure58.1.2.bioconductor_and_r_image_058.jpg. Figure59.1.2.bioconductor_and_r_image_059.jpg. Figure60.1.2.bioconductor_and_r_image_060.jpg. 2.  sapply().  sapply() behaves similar to lapply() by applying a function to a list but tries to simplify the output in the following ways;. ● If the result is a list where every element is length 1, then a vector is returned. ● If the result is a list where every element is a vector of the same length (> 1), a matrix is returned. ● If it can’t ﬁgure things out, a list is returned.  sapply() vs lapply() output. Figure61.1.2.bioconductor_and_r_image_061.jpg. Figure62.1.2.bioconductor_and_r_image_062.jpg.  sapply() tries to simplify output from lapply to either vector or matrix. Figure63.1.2.bioconductor_and_r_image_063.jpg. 3.  tapply().  tapply() is used to apply a function over a subset of a vector. The arguments to tapply() are as follows: ● X is a vector. ● INDEX is a factor or a list of factors (or else they are coerced to factors). ● FUN is a function to be applied. ● … contains other arguments to be passed FUN. ● simplify, should we simplify the result?. Figure64.1.2.bioconductor_and_r_image_064.jpg.  tapply() – example. Figure65.1.2.bioconductor_and_r_image_065.jpg. We can specify simplify to be FALSE. Figure66.1.2.bioconductor_and_r_image_066.jpg. 4.  apply(). ● The apply() function is used to a evaluate a function (often an anonymous one) over the margins (rows or columns) of an array (including matrices and data frames) for example compute averages of columns. ● However, it can be used with general arrays, for example, to take the average of an array of matrices. ● Using apply() is not really faster than writing a loop, but it works in one line and is highly compact. ● The arguments to apply() are: X is an array. ○ MARGIN is an integer vector indicating which margins should be “retained”. ○ FUN is a function to be applied. ○ .  is for other arguments to be passed to FUN. Figure67.1.2.bioconductor_and_r_image_067.jpg.  apply() - example. Mean of each column. Figure68.1.2.bioconductor_and_r_image_068.jpg. Mean of each row. Figure69.1.2.bioconductor_and_r_image_069.jpg. Col/Row Sums and Means. For computing column/row sums and column/row means of matrices, there are some useful shortcuts;. ● rowSums = apply(x, 1, sum). ● rowMeans = apply(x, 1, mean). ● colSums = apply(x, 2, sum). ● colMeans = apply(x, 2, mean). The shortcut functions are heavily optimized and hence are much faster, but you probably won’t notice unless you’re using a large matrix. Another nice aspect of these functions is that they are a bit more descriptive. It’s arguably clearer to write colMeans(x) in your code than apply(x, 2, mean).  apply() - More examples. We can pass in arguments to the … for function. Figure70.1.2.bioconductor_and_r_image_070.jpg. We can also use a higher dimension array. Figure71.1.2.bioconductor_and_r_image_071.jpg. Or do a similar thing with rowMeans. Figure72.1.2.bioconductor_and_r_image_072.jpg. 5.  mapply(). ● The mapply() function is a multivariate apply of sorts which applies a function in parallel over a set of arguments. ● Functions such as lapply() and friends only iterate over a single R object (say a list). ● What if you want to iterate over multiple R objects in parallel (say 2 vectors)? This is what mapply() is for. ● The arguments to mapply() are;. ○ FUN is a function to apply. ○ .  contains R objects to apply over. ○ MoreArgs is a list of other arguments to FUN. ○ SIMPLIFY indicates whether the result should be simpliﬁed. Figure73.1.2.bioconductor_and_r_image_073.jpg.  mapply() - example.  mapply() has a different argument order from lapply(), the function to apply comes ﬁrst rather than the object to iterate over. The R objects over which we apply the function are given in the .  argument because we can apply over an arbitrary number of R objects. Example: Instead of typing:  list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1)). Figure74.1.2.bioconductor_and_r_image_074.jpg.  mapply() - Using custom function. Figure75.1.2.bioconductor_and_r_image_075.jpg. Figure76.1.2.bioconductor_and_r_image_076.jpg. Installing R Packages. About R packages. ● When you download R from the Comprehensive R Archive Network (CRAN), you get that “base” R system. ● The base R system comes with basic functionality implements the R language. ● One reason R is so useful is the large collection of packages that extend the basic functionality of R. ● R packages are developed and published by the larger R community. Where to obtain R packages. There are different locations to get R packages from: 1. CRAN (Comprehensive R Archive Network): primary location for obtaining R packages. Packages from CRAN are installed using the install.packages() function. 2. Bioconductor project: Stores many tools for biological applications. Packages from Bioconductor are installed using BiocManager::install(). 3. Github: Contains mainly development version packages not published on either CRAN or Bioconductor. CRAN provides a grouping of packages related to a given topic through the CRAN Task Views. Installing an R package. ● Packages can be installed with the install.packages() function in R. ● To install a single package, pass the name of the lecture to the install.packages() function as the ﬁrst argument. ● The following the code installs the slidify package from CRAN. Figure77.1.2.bioconductor_and_r_image_077.jpg. ● This command downloads the slidify package from CRAN and installs it on your computer. ● Any packages on which this package depends will also be downloaded and installed. Installing multiple packages. ● You can install multiple R packages at once with a single call to install.packages(). ● Place the names of the R packages in a character vector. Figure78.1.2.bioconductor_and_r_image_078.jpg. Install R packages from Rstudio. Figure79.1.2.bioconductor_and_r_image_079.jpg. Figure80.1.2.bioconductor_and_r_image_080.jpg. Loading R Packages. ● Installing a package does not make it immediately available to you in R you must load the package. ● The library() function is used to load packages into R. The following code is used to load the ggplot2 package into R. Figure81.1.2.bioconductor_and_r_image_081.jpg. ● Any packages that need to be loaded as dependencies will be loaded ﬁrst, before the named package is loaded. ● NOTE: Do not put the package name in quotes!. ● Some packages produce messages when they are loaded (but some don't). Introduction to tidyverse R Package. [- dplyr, - ggplot2]. What is Tidyverse. Tidyverse is a collection of R packages designed to make data manipulation and visualization more intuitive and efﬁcient. Key Features of Tidyverse: ● Tidy data: Organizing data into features (columns) and observations (rows). ● Data manipulation: transforming and organizing data preparing it for analysis, visualization, or modeling. ● Piping (%>%): Allows chaining operations together, making code more readable via the pipe character. ● Data Visualization: Tidyverse follows the "Grammar of Graphics" for creating visualizations to represent data. Concept of Tidy data. There are three interrelated rules that make a dataset tidy: 1. Each variable is stored in its own column; each column is a variable. 2. Each observation is stored in its own row; each row is an observation. 3. Each value of a variable is stored in a cell of the table; each cell is a single value. Figure82.1.2.bioconductor_and_r_image_082.jpg. Tidyverse packages. “The Tidyverse suite of packages introduces users to a set of data structures, functions and operators to make working with data more intuitive, but is slightly diﬀerent from the way we do things in base R. ”. Figure83.1.2.bioconductor_and_r_image_083.jpg. The dplyr Package. Figure84.1.2.bioconductor_and_r_image_084.jpg. ● dplyr provides a set of functions for efﬁcient data manipulation tasks. ● It does not provide any “new” functionality to R per se, in the sense that everything dplyr does could be done with base R, but it greatly simpliﬁes existing functionality in R. ● One useful contribution is that the dplyr functions are very fast, as many key operations are coded in C++.  dplyr Grammar. Some of the key functions (“verbs”) provided by the dplyr package are;. ● select: return a subset of the columns of a data frame, using a ﬂexible notation. ● ﬁlter: extract a subset of rows from a data frame based on logical conditions. ● arrange: reorder rows of a data frame. ● rename: rename variables in a data frame. ● mutate: add new variables/columns or transform existing variables. ● summarise / summarize: generate summary statistics of different variables in the data frame, possibly within strata. ● %>%: the “pipe” operator is used to connect multiple verb actions together into a pipeline.  dplyr - Function properties. All of the functions that we will discuss have a few common characteristics;. ● The ﬁrst argument is a data frame. ● The subsequent arguments describe what to do with the data frame. ● You can refer to columns in the data frame directly without using the $ operator (just use the column names). ● The return result of a function is a new data frame. ● Data frames must be properly formatted and annotated for this to all be useful. In particular, the data must be tidy. In short, there should be one observation per row, and each column should represent a feature or characteristic of that observation. Data to be used. Link to the zipped data: Figure85.1.2.bioconductor_and_r_image_085.jpg. Figure86.1.2.bioconductor_and_r_image_086.jpg. 1.  select() - Subset columns. ● The select() function can be used to select columns of a data frame that you want to focus on. ● We can specify a range of columns to subset eg (col1:col5) – these columns have to be adjacent to each other. ● Can also be used to exclude (omit) columns from a dataframe using the negative sign. ● It also allows a special syntax that to specify variable names based on patterns. ● Use the to ?select get more information about the function and more general regular expressions.  select() – Examples. Figure87.1.2.bioconductor_and_r_image_087.jpg. Figure88.1.2.bioconductor_and_r_image_088.jpg. Figure89.1.2.bioconductor_and_r_image_089.jpg. Figure90.1.2.bioconductor_and_r_image_090.jpg. 2.  ﬁlter() - Subset rows. The ﬁlter() function is used to extract subsets of rows from a data frame. Say you wanted to;. ● extract the rows of the chicago data frame where the levels of PM2. 5 are greater than 30. ● extract the rows where PM2. 5 is greater than 30 and temperature is greater than 80 degrees. Figure91.1.2.bioconductor_and_r_image_091.jpg. Figure92.1.2.bioconductor_and_r_image_092.jpg. 3.  arrange() - Reorder rows. ● The arrange() function is used to reorder rows of a data frame according to one of the variables/columns. ● It simpliﬁes the process of reordering rows of a data frame (while preserving corresponding order of other columns) quite a bit. ● Say order the rows of the data frame by date so that the ﬁrst row is the earliest (oldest) observation and the last row is the latest (most recent) observation. ● Columns can be arranged in descending order too by using the special desc() operator.  arrange() – Examples. Figure93.1.2.bioconductor_and_r_image_093.jpg. Figure94.1.2.bioconductor_and_r_image_094.jpg. Figure95.1.2.bioconductor_and_r_image_095.jpg. Figure96.1.2.bioconductor_and_r_image_096.jpg. Figure97.1.2.bioconductor_and_r_image_097.jpg. 4.  rename() - Rename a column. The syntax inside the rename() function is to have the new name on the left-hand side of the = sign and the old name on the right-hand side. Figure98.1.2.bioconductor_and_r_image_098.jpg. Figure99.1.2.bioconductor_and_r_image_099.jpg. 5.  mutate() - create new variables. The mutate() function allows creation of new variables that are derived from existing variables. Create a new variable by subtracting the mean from the data. Figure100.1.2.bioconductor_and_r_image_100.jpg. %>% - The pipe operator. ● The pipeline operator %>% is very handy for stringing together multiple dplyr functions in a sequence of operations. ● Notice above that every time we wanted to apply more than one function, the sequence gets buried in a sequence of nested function calls that is difﬁcult to read, i.e. , third(second(ﬁrst(x))). ● The %>% operator allows you to string operations in a left-to-right fashion, i.e. , ﬁrst(x) %>% second %>% third. %>% - Example. 1.  create a new variable pm25.quint. 2.  split the data frame by that new variable. 3.  compute the mean of o3 and no2 in the sub-groups deﬁned by pm25.quint. Figure101.1.2.bioconductor_and_r_image_101.jpg. Figure102.1.2.bioconductor_and_r_image_102.jpg. Figure103.1.2.bioconductor_and_r_image_103.jpg. Extra Resources. ● dplyr & tidyverse ofﬁcial site: ● R programming for Data Science: ● R for Data Science: ● R for Graduate Students: Grammar of Graphics. Figure104.1.2.bioconductor_and_r_image_104.jpg. “Create Stunning Visualizations in R”.  ggplot2 package. ● ggplot2 package is a data visualization package for creating graphs in R. ● It breaks the graphs into individual components such as axes, scales, colors, objects, among others onto which the plot is built. ● Each of these components can be modiﬁed individually (separately) in a way that is both ﬂexible and user-friendly. ● When given components are not speciﬁed, ggplot2 uses sensible defaults. Figure105.1.2.bioconductor_and_r_image_105.jpg.  ggplot2 - Essential elements. There are 3 essential elements to any ggplot call: 1.  aesthetic: An aesthetic tells the ggplot function which variables are being mapped to the x axis, y axis, (and often other attributes of the graph, such as the color ﬁll). Intuitively, the aesthetic can be thought of as what you are graphing.  ggplot(mydata, aes(x = var)) – One variable.  ggplot(mydata, aes(x = var1, y = var2)) – 2 variables. 2.  geom: A geom or geometry tells ggplot about the basic structure (type) of the graph. Intuitively, the geom can be thought of as how you are graphing it. 3. Other options, such as a graph title, axis labels and overall theme for the graph. BirdsNest dataset (dat). Figure106.1.2.bioconductor_and_r_image_106.jpg.  ggplot2: Aesthetics - 1. The aesthetics initialize an empty plotting canvas on to which a given plot type can be made. Figure107.1.2.bioconductor_and_r_image_107.jpg.  ggplot2: geoms. ● geom functions specify the type of graph (points, lines, etc) to add to the plot. ● There are quite a number of geom functions: ❖ geom_dotplot() - This says add a dotplot geometry to the graph. ❖ geom_histogram() - adds a histogram geometry to the graph. ❖ geom_violin() - adds a violin plot geometry to the graph. ❖ geom_beeswarm() - adds a beeswarm geometry to the graph. ❖ geom_point() - adds a point (scatterplot) geometry to the graph. ❖ geom_smooth() - adds a smoother to the graph. ❖ And many more. ● Geoms as well as other options are added to the ggplot canvas using the “+”.  ggplot2: geoms - 2. We specify a scatter plot using the geom_point(). Figure108.1.2.bioconductor_and_r_image_108.jpg.  ggplot2 - Adding colors to plot. We can add colors to the plots using the “color” argument in the aesthetics.  ggplot2 will automatically create a scale for you that you can adjust based on your needs. Figure109.1.2.bioconductor_and_r_image_109.jpg. Figure110.1.2.bioconductor_and_r_image_110.jpg.  ggplot2: Adjusting Scales - 3.  ggplot chooses the type of scale to use for an aesthetic based on the class of data it is mapping to that aesthetic. Characters and factors are usually discrete scales. Numerical values are usually continuous scales. Figure111.1.2.bioconductor_and_r_image_111.jpg.  ggplot2 - theme. ● The “theme” allows you control the overall appearance and styling of a plot such as;. ○ Changing background of plot and background color. ○ Include or remove gridlines. ○ Modify font types and sizes. ○ Text alignment. ○ Modify plot axes, and many more…. ● Themes allow you to customize the visual elements of your plot to make it more visually appealing or to adhere to a speciﬁc style guide, and creating publication-quality data visualizations. ● Run ?theme to know more about different themes.  ggplot2: theme - example. Figure112.1.2.bioconductor_and_r_image_112.jpg.  ggplot2: theme - Using deﬁned theme. Figure113.1.2.bioconductor_and_r_image_113.jpg.  ggplot2: ggsave() - Save plot to ﬁle. ● The ggsave function is used to save your generated plot to a ﬁle. ● It supports saving the image ﬁle in different formats such as PNG, JPEG, TIFF, PDF. ● Some of the common arguments are;. ○ ﬁlename: Plot ﬁlename to create. ○ plot: The plot to save, defaults to last plot displayed. ○ width, height: The plot dimensions to save. If not supplied, uses the size of current graphics device. ○ dpi: Plot resolution (quality), defaults to 300. Figure114.1.2.bioconductor_and_r_image_114.jpg. Figure115.1.2.bioconductor_and_r_image_115.jpg.  ggplot2 - Self-paced tutorial. Creating Analysis Reports in R (R Markdown). What is RMarkdown?. ● R Markdown is a document format that combines R code, its output, and text elements (description) into a single document to create a single analysis report. ● Unlike using R scripts where you can write R code, R Markdown allows you combine code, comments and outputs into a single ﬁle. ● It can be used to display plots (ﬁgures), tables and general text outputs. ● The knitr package is used to convert your R Markdown document (. Rmd) into a nicely formatted report in a range of output formats including; PDF, HTML or a Word document. A knit button is present in Rstudio for the report generation. Figure116.1.2.bioconductor_and_r_image_116.jpg. R Markdown scripts - Components. An R Markdown document has 3 basic components;. 1. YAML header: Contains metadata about the document, including the title, author, and output format. It is enclosed in the opening and closing 3 dashes (---). 2. Code chunks: These embed the R code. The chunks are enclosed in three backticks (```) and allow you to write, run, and display the results of R code directly in your document. Another supported language can be speciﬁed besides R. 3. Markdown formatted text. Figure117.1.2.bioconductor_and_r_image_117.jpg. Figure118.1.2.bioconductor_and_r_image_118.jpg. R Markdown Cheatsheet - 1. Figure119.1.2.bioconductor_and_r_image_119.jpg. R Markdown Cheatsheet - 2. Figure120.1.2.bioconductor_and_r_image_120.jpg;